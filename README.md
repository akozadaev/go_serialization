# Go Serialization Examples

---


### 1. `gob/main.go` — Нативная сериализация Go [main.go](gob/main.go)

**Назначение**  
Если нужно быстро сохранить объекты Go в бинарный формат — `gob` идеален. Он работает только внутри Go-проектов (не для обмена с другими языками).

**Что делает?**
- Создаёт структуру `Book`
- Сериализует её в `bytes.Buffer`
- Десериализует обратно
- Сравнивает оригинальный и восстановленный объект — если совпадают → успех!

```go
book := Book{Title: "Go Programming Language", Author: "Gopher"}
// ... код сериализации и десериализации ...
fmt.Println("Gob сериализация/десериализация прошла успешно!")
```

> **Плюс**: очень быстрый, поддерживает вложенные структуры, каналы, функции (если нужно).  
> **Минус**: не читаемый человеком, несовместим с другими языками.

---

### 2. `json/main.go` — Базовая работа с JSON

**Зачем?**  
Самый популярный формат для API, конфигов, обмена данными. Простой и универсальный.

**Что делает?**
- Определяет структуру `Person`
- Сериализует в JSON строку
- Десериализует обратно
- Выводит результаты

---

### 3. `json/advanced/custom_json/main.go` — Кастомная сериализация

**Зачем?**  
Когда стандартный `time.Time` в JSON выдаёт слишком много информации (`2025-09-28T00:00:00Z`), а тебе нужно только `"2025-09-28"`.

**Что делает?**
- Создаёт обёртку `CustomTime` вокруг `time.Time`
- Реализует методы `MarshalJSON()` и `UnmarshalJSON()`
- Сериализует событие с датой в нужном формате
- Проверяет, что после десериализации дата осталась той же

```go
type CustomTime struct { time.Time }

func (ct CustomTime) MarshalJSON() ([]byte, error) {
	return json.Marshal(ct.Format("2006-01-02"))
}
```

>**Полезно**: когда хочешь контролировать, как данные выглядят в JSON — например, скрывать поля, менять форматы, добавлять префиксы.

---

### 4. `json/advanced/dynamic_json/main.go` — Работа с неизвестными структурами

**Зачем?**  
Иногда ты получаешь JSON, структура которого заранее неизвестна — например, API возвращает разные типы событий.

**Что делает?**
- Парсит JSON в `map[string]interface{}` — удобно, но требует ручного приведения типов.
- Альтернатива — использует `json.RawMessage`, чтобы отложить парсинг части данных до момента, когда станет ясно, что там.

```go
type Event struct {
	Type string          `json:"type"`
	Data json.RawMessage `json:"data"`
}
```

>**Плюс RawMessage**: можно сначала прочитать метаданные (например, `type`), а потом уже распарсить `data` под нужную структуру. Это безопаснее и чище.

---

### 5. `json/advanced/file_json/main.go` — Запись и чтение JSON из файла

**Зачем?**  
Часто нужно сохранить настройки, конфиги или кэш в файл. JSON — отличный выбор.

**Что делает?**
- Создаёт структуру `Settings`
- Записывает её в `config.json` с отступами (красиво!)
- Читает обратно из файла
- Выводит загруженные данные

```go
encoder.SetIndent("", "  ") // красивый вывод
```

---

### 6. `xml/xml.go` — Сериализация в XML

**Зачем?**  
XML всё ещё используется в legacy системах, SOAP API, конфигах (например, Spring, Maven). Go поддерживает его “из коробки”.

**Что делает?**
- Сериализует структуру `Book` в XML
- Добавляет декларацию `<?xml version="1.0" encoding="UTF-8"?>` для читаемости
- Десериализует обратно
- Проверяет, что объект восстановился правильно

```go
xmlStr := xml.Header + string(xmlData2)
```

>**Важно**: по умолчанию XML не содержит декларации — её нужно добавлять вручную, если нужна полная совместимость.

---

## Вывод

Сериализация — не просто “запихать объект в строку”. Это мощный инструмент, который нужно понимать глубоко.  
Этот репозиторий служит демонстрацией:

Быстро начать работать с JSON/XML/gob  
Разобраться в кастомной сериализации  
Безопасно обрабатывать динамические данные  
Сохранять и загружать конфиги из файлов